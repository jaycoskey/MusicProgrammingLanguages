<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Music Programming Languages</title>
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Jay Coskey">
		<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/white.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/pdf.css' : 'css/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<script src="js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>
<div class="reveal">
<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section id="title">
		<h1>Music Programming Languages</h1>
		<h3>Creating and Analyzing Tonal Music and Soundscapes</h3>
		<p align="center">Jay Coskey</p>
		<p align="center">2016-05-04</p>
		<b>
		<pre style="background-color: #d0ffd0; font-size: 48px;">
reveal.js tips:
  Use n or &lt;space> to advance to the next slide.
  Use p to return to the previous slide.
  Use &lt;Esc> to toggle an overview of all slides.
  Use ? to see a list of all keyboard commands.
  Use s to see the speaker notes.</pre>
		</b>
</section>

<section id="section_introduction">
	<section id="introduction">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/title">&#x25c1;</a>
			Introduction
			<a href="#/euterpea">&#x25b7;</a>
		</h2>
		<em>
		"To play the wrong note is insignificant; to play without passion is inexcusable."
		</em>
		- Beethoven
		<br/><br/>
		<div style="text-align: left;">
			<table>
				<tr>
					<td align="left" width="800" style="vertical-align:top; font-size: 36px;">
						<p><b>Music runs deep through the human psyche:</b></p>
						<ul>
							<li> Music is universal and
							<a href="http://news.nationalgeographic.com/news/2009/06/090624-bone-flute-oldest-instrument.html">
								ancient</a>.
							<li> The psychology of music is murky.
							<li> Music turns movies into blockbusters.
						</ul>
						<p><b>Traditional training vs. software</b></p>
						<ul>
							<li> Tradition: Train for 10+ years.
							<li> Faster with software?
							<li> Difference in resulting skills?
						</ul>
						<p><b>Any room for non-humans?</b></p>
						<ul>
							<li> <font color="blue">Compare within a piece or within a corpus</font>
							<li> Recognize instruments, genre, mood, etc.
							<li> Compose original music (limited success)
						</ul>
					</td>
					<td>
						<img src="img/HappyBirthdayStandard.svg"
							width="600"
							height="300"
							border="0"
							alt="Score of Happy Birthday"/>
						<br/>
						Happy Birthday:
						<a href="midi/HappyBirthdayStandard.mid">original</a>, &amp;
						<a href="midi/HappyBirthdayVariation.mid">modified</a>
						<br/>
						<img src="img/HappyBirthdayVariation.svg"
							width="600"
							height="300"
							border="0"
							alt="Score of variation on Happy Birthday"/>
						<!--
						<img src="img/InTheMoodSample.svg"
							width="600"
							height="200"
							alt="Score of Happy Birthday"/>
						-->
					</td>
				</tr>
			</table>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="intro_tonal">
		<h3>Introduction &mdash; Tonal Music</h3>
		<p>Examples: "Happy Birthday to You", "Greensleeves", "Yellow Submarine"</p>
		<div style="text-align: left;">
			<table>
				<tr>
					<td width="800" style="vertical-align:top; font-size: 36px;">
						<br/>
						<ul>
							<li> Time domain: Rhythm
							<li> Freq domain: Temperament, scales, keys, chords
							<li> Time & Freq: Melodies, chord progressions, texture
							<li> Sheet music: Western notation &amp; lesser known
								<ul>
									<li> Scores, staves, measures, notes, accidentals....
								</ul>
							<li> Score file formats: MusicXML, ABC, LilyPond, MusicTeX, etc.
							<li> Sound file formats:
								<a href="https://www.cs.cmu.edu/~music/cmsip/readings/MIDI%20tutorial%20for%20programmers.html">MIDI</a>
							<li> Scorewriters (e.g., MuseScore)
						</ul>
					</td>
					<td>
						<img src="https://upload.wikimedia.org/wikipedia/en/d/da/Modern_Musical_Notation.jpg"
							align="right"
							width="700"
							alt="Annotated treble clef"
						/>
						<img src="http://www.johnloomis.org/ece561/notes/piano/music_notation.jpg"
							align="right"
							width="700"
							alt="Annotated grand clef"
						/>
					</td>
				</tr>
			</table>
		</div>
		<aside class="notes">
		<ul>
			<li> Chromatic              [1,1,1,  1,1,1,  1,1,1,  1,1]
			<li> Major pentatonic       [2, 2, 3, 2, 3]       -- C-D-E-G-A-C
			<li> Minor pentatonic       [3, 2, 2, 3, 2]       -- A-C-D-E-G-A
			<li> Blues major            [2, 3, 2, 2, 3]       -- D-E-G-A-B-D
			<li> Blues minor            [3, 2, 3, 2, 2]       -- B-D-E-G-A-B
			<li> Egyptian suspended:    [2, 3, 2, 3, 2]       -- A-B-D-E-G-A
			<li> Major (=Ionian)        [2, 2, 1, 2, 2, 2, 1]
			<li> Minor (=Aeolian)       [2, 1, 2, 2, 1, 2, 2]
			
			<li> Ionian   (=Major)      [2, 2, 1, 2, 2, 2, 1] -- I   -- C-D-E-F-G-A-B-C
			<li> Dorian                 [2, 1, 2, 2, 2, 1, 2] -- II  -- D-E-F-G-A-B-C-D
			<li> Phrygian               [1, 2, 2, 2, 1, 2, 2] -- III -- E-F-G-A-B-C-D-E
			<li> Lydian                 [2, 2, 2, 1, 2, 2, 1] -- IV  -- F-G-A-B-C-D-E-F
			<li> Mixolydian             [2, 2, 1, 2, 2, 1, 2] -- V   -- G-A-B-C-D-E-F-G
			<li> Aeolian  (=Minor)      [2, 1, 2, 2, 1, 2, 2] -- VI  -- A-B-C-D-E-F-G-A
			<li> Locrian                [1, 2, 2, 1, 2, 2, 2] -- VII -- B-C-D-E-F-G-A-B
			
			<!-- These Indian scales are from https://github.com/cavedweller/Indian-Euterpea/ -->
			<li> Bilawal  (=Major)      [2, 2, 1, 2, 2, 2, 1]
			<li> Khamaj   (=Mixolydian) [2, 2, 1, 2, 2, 1, 2]
			<li> Kafi     (=Dorian)     [2, 1, 2, 2, 2, 1, 2]
			<li> Asavari  (=Minor)      [2, 1, 2, 2, 1, 2, 2]
			<li> Bhairavi (=Phrygian)   [1, 2, 2, 2, 1, 2, 2]
			<li> Bhairav                [1, 3, 1, 2, 1, 3, 1]
			<li> Kalyan   (=Lydian)     [2, 2, 2, 1, 2, 2, 1]
			<li> Marva                  [1, 3, 2, 1, 2, 2, 1]
			<li> Purvi                  [1, 3, 2, 1, 1, 3, 1] 
			<li> Todi                   [1, 2, 3, 1, 1, 3, 1]
		</ul>
		</aside>
	</section>

	<section id="intro_musicxml_lilypond">
		<h3>Introduction &mdash; MusicXML and LilyPond</h3>
		<div style="text-align: left;">
		Both of these involve the sound of a piece and the appearance of its score.
			<ul>
				<li> <b>MusicXML:</b> Standard format for computer exchange of score info
					<ul>
						<li> Most music apps read and/or write MusicXML.
						<li> The schema file, musicxml.xsd, is ~5400 lines long.
						<li> Significant undertaking to support
					</ul>
				<li> <b>LilyPond:</b> Popular human-writeable system for recording score info
					<ul>
						<li> Better than MusicXML as a source to learn about music
						<li> Many convenience features, i.e., chord names, relative pitch
						<li> Separate GUI front-end called Frescobaldi
						<ul>
							<li> Some features in command-line not present in GUI (e.g., SVG output)
						</ul>
					</ul>
				</ul>
				<pre style="font-size: 28px;">
\version "2.18.2"
\header { title = "Happy Birthday" }
global = { \key c \major
           \time 3/4
         }
right = \relative c'' {\global g8 g8 a4 g4        c4 b2      }
left  = \relative c   {\global r4 \chordmode{c,2} r4 &lt;d f g>2}
\score {
  \new PianoStaff \with {instrumentName = "Piano"}
  &lt;&lt;
    \new Staff = "right" \with {midiInstrument = "acoustic grand"} \right
    \new Staff = "left"  \with {midiInstrument = "acoustic grand"} {\clef bass \left}
  >>
  \layout { }
  \midi {\tempo 4=100}
}</pre>
		</div>
		<aside class="notes">
			Note: MuseScore used to support printing to LilyPond format,
				but instead focused support on MusicXML,
				and left MusicXML-to-LilyPond support to others.
		</aside>
	</section>

	<section id="intro_soundscapes">
		<h3>Introduction &mdash; Soundscapes</h3>
		<div style="text-align: left;">
		Soundscape examples: The THX Sound Effect
		("<a href="https://www.youtube.com/watch?v=M3lO9Dt3kjA">Deep Sound</a>"), or the
		<a href="https://www.youtube.com/watch?v=-0tPBQddeJs">Futurama Theme</a>
		<ul>
			<li> Soundscapes are more amorphous than tonal music.
			<li> Most digital audio workstations (DAWs) are written in C++.
			<li> At a low level, sound can be represented by arrays of numbers,
				and the domain-specific language (DSL) for arrays of numbers
				has already been written: Fortran, back in 1957 by J. Backus,
				famous for Backus-Naur Form (BNF).
			<li> Tools: DAWs, FFTs
			<li> Most of this talk will focus on tonal music.
		</ul>
		</div>
		<aside class="notes">
		<ul>
			<li> Joke: Seven years after Jim Backus invented Fortran, he was stranded with
				six other castaways on Gilligan's Island.
			<li> The Futurama Theme is based on a trippy 1967 song called
				<a href="https://www.youtube.com/watch?v=AOqfWj0HqNE">
				Psych√© Rock
				</a> by Pierre Henry.
		</ul>
		</aside>
	</section>

	<section id="intro_useCases">
		<h3> Introduction &mdash; Other Use Cases</h3>
		<div style="text-align: left;">
		<ul>
			<li> Music Data Mining
				<ul>
					<li> Music corpora (e.g., Wikifonia), compression, storage, indexing, tagging
					<li> Assisted and autonomous composition, including stochastic systems
					<li> Generations of chords from melody (e.g., using HMMs)
					<li> Instrument, artist, genre, mood identification (using signal processing)
					<li> Measuring song similarity (e.g., copyright infringement), incl. phrase identification
					<li> Song search (incl. search by humming) &amp; recommendations, using metadata
				</ul>
			<li> Detection of patterns, including duplicated subexpressions and nearly-duplicated subexpressions.
				<ul>
					<li> (Think of string algorithms, but generalized to apply to music.)
				</ul>
			<li> Physical simulation of instruments and acoustics
			<li> Visualization
		</ul>
		</div>
		<aside class="notes">
			Key-finding algorithms (CBMS profile, Beyesian profile, and Krumhansl's profile)
				https://musescore.org/en/node/16444
		</aside>
	</section>

	<section id="intro_math">
		<h3>Introduction &mdash; Mathematical Music Theory</h3>
		<div style="text-align: left;">
		<ul>
			<li> Three-note chord transformations first formally explored by Hugo Riemann (1849-1919)
			<ul>
				<li> A <em>Schritt</em> transposes one chord (i.e., shifts its frequency).
				<li> A <em>Wechsel</em> changed a major triad into a minor triad and vice versa.
			</ul>
			<li> Later generalized to P, L, R operations in Neo-Riemannian Theory and Schenkerian analysis.
				<!-- Heinrich Schenker (1868-1935).  Schenkerian analysis is subjective -->
			<li> More recent work:
			<ul>
				<li> Transformational theory, by David Lewin, 1980s.
				<li> Generalized Contextual Groups (extension of the PLR group), by Fiore and Satyendra, 2005.
				<li> Uniform Triadic Transformations UTTs, by Julian ("Jay") Hook, 2002.
			</ul>
		</ul>
		<br/><br/>
		<b>Q:</b> How useful in addressing issues outside their scope?<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Don't forget the human listener, and don't mistake pattern for passion.
		</div>
		<aside class="notes">
			<ul>
			<li> Hugo Riemann should not be confused with the mathematician/geometer Bernhard Riemann.
			<li> In Star Trek: The Next Generation, season 3, episode 9, Wesley Crusher was studying
				"a locally Euclidian metrization of a k-fold contravariant Riemannian tensor field".
				That's a different Riemann than Hugo Riemann.
			</ul>
		</aside>
	</section>

	<section id="intro_languages">
		<h3>Introduction &mdash; Music Programming Languages (MPLs)</h3>
		<div style="text-align: left; font-size: 28px;">
		<ul>
			<li> There are
				<a href="https://en.wikipedia.org/wiki/List_of_audio_programming_languages">20+</a>
				high-level MPLs.
			<li> If you include transcription-oriented ones (think HTML, but for music),
				then it's more like
				<a href="http://nosuch.com/plum/cgi/showlist.cgi?sort=name&concise=yes">100+</a>.
			<li> Soundscape DSLs came first ... but now there's a lot of support for melodic music.
			<li> Here is a short list of a few:
			<table>
			<tr>
				<td>MUSIC-N</td>
					<td>1957</td>
					<td>A very early music DSL
					</td>
			</tr>
			<tr>
				<td>Csound</td>
					<td>1986</td>
					<td>RTperformance, sound synth, algorithmic composition, acoustic research
					</td>
			</tr>
			<tr>
				<td>Pure Data (Pd)</td>
					<td>1990s</td>
					<td>A graphical language for RT audio+video synthesis,
						like Max/MSP in the ‚ÄúPatcher‚Äù family
					</td>
			</tr>
			<tr>
				<td>ChucK</td>
					<td>2004</td>
					<td>RT synthesis, live coding, pedagogy, acoustic research, algo composition
					</td>
			</tr>
			<tr>
				<td>SuperCollider (SC)</td>
					<td>???</td>
					<td>Smalltalk-inspired language.
						RT synthesis, live coding, algorithmic composition, acoustic research
						<ul>
						<li> Overtone &mdash; A toolkit w/ a Closure API to SC and the compositional library ‚ÄúLeipzig‚Äù
						<li> Skoarcy  &mdash; A toolset in Skoar, a high-level music composition DSL that runs on SC
						</ul>
					</td>
			</tr>
			<tr>
				<td>Strasheela</td>
					<td>2004?-2012</td>
					<td>Constraint-based composition, based on the Oz language
					</td>
			</tr>
			</table>
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_transcription">
	<section id="transcription">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_introduction">&#x25c1;</a>
			Song Transcription Languages (1/2)
			<a href="#/section_euterpea">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		Some simple MPLs don't support variables or loops,
			so they can't support any of the more complex use cases.
		<br/><br/>
		But they can be good for representing scores in song databases.  Here's a brief taste.
		<ul>
			<li> ABC notation (v2.1 - Dec 2011) is a concise, popular, and well-supported
				<pre style="font-size: 32px; white-space: pre-line;">
				T:Mary had a little lamb
				M:C		% meter
				L:1/4   % basic note length
				K:F		% key
				AGFG|AAA2|GGG2|AAA2|
				AGFG|AAAA|GGAG|F4|]
				</pre>
			<li> LilyPond is useful for printing beautiful scores.
				<pre style="font-size: 32px; white-space: pre-line;">
				song = \relative c' {
					\clef treble
					\key c \major
					\time 4/4
					e4 d c d e e e2 d4 d d2 e4 e e2
					e4 d c d e e e c d d e d c2 r2
				}
				\score { \new Staff \song }
				</pre>
			<li> MusicTeX is also available to add scores into TeX documents.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
	
	<section id="transcription">
		<h3>Song Transcription Languages (2/2)</h3>
		<div style="text-align: left;">
		    <ul>
			<li> Alda (inspired by LilyPond and Music Macro Language) was designed
				to find the "sweet spot" between simple/intuitive syntax and 
				depth of features.
				It's implemented in Clojure, and emits a Clojure DSL,
				which is exposed as a library.
				<pre style="font-size: 32px; white-space: pre-line;">
				piano: o3
				g8 a b > c d e f+ g | a b > c d e f+ g4
				g8 f+ e d c &lt; b a g | f+ e d c &lt; b a g4
				&lt;&lt; g1/>g/>g/b/>d/g
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_euterpea">
	<section id="euterpea">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_transcription">&#x25c1;</a>
			Euterpea
			<a href="#/section_csound">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		<ul>
			<li> Euterpea (v2): A music DSL embedded in Haskell
			<li> First up because:
				<ul>
					<li> (a) Supports both tonal and full-spectrum music
					<li> (b) Core similicity &rArr; Better focus on the domain of music itself.
				</ul>
			<li> Euterpea (and a related library and PDF: The Haskell School of Music)
				was written by:
				<ul>
					<li> the late Paul Hudak
					<li> Hai ("Paul") Liu,
					<li> Eric Cheng,
					<li> Donya Quick
					<li> Daniel Winograd-Cort
				</ul>
			<li> Now maintained by Quick &amp; Winograd-Cort.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_geting_started">
		<h2>Euterpea &mdash; Getting Started</h2>
		<div style="text-align: left;">
		<h4>Haskell School of Music</h4>
		<ul>
			<li> Download the PDF "Haskell School of Music" (HSoM.pdf).  (Could also serve as intro to Haskell.)
			<li> Can be thought of as a follow-on to Paul Hudak's "The Haskell School of Expression" (2000).
		</ul>
		<br><br>
		<h4>Installation</h4>
		<ul>
			<li>Read installation instructions at  <a href="http://www.euterpea.com/download-and-installation/">http://www.euterpea.com/download-and-installation/</a>
			<li>Install the 32-bit version of Haskell Platform.  (Sound doesn't work w/ 64-bit version.)
			<li>Install Euterpea2 and the Haskell School of Music (HSoM) from github.
			<li>Test installation ("MUI" = "Musical User Interface)
				<pre style="font-size: 32px; white-space: pre-line;">
					% ghci
					ghci> import Euterpea
					ghci> play $ c 4 qn  -- Play a quarter note, with sensible defaults
					ghci> import HSoM
					ghci> :load  HSoM.Examples.MUIExamples2
					ghci> import HSoM.Examples.MUIExamples2
					ghci> bifurcate     -- GUI app/test that lives in MUIExamples2
				</pre>
		</ul>
		</div>
		<aside class="notes">
			Euterpea is currently maintained by Donya Quick and Dan Winograd-Cort.
		</aside>
	</section>

	<section id="euterpea_model">
		<h3>Euterpea &mdash; Modeling (Tonal) Music</h3>
		<div style="text-align: left;">
		At the heart of Euterpea's representation of music is the following Primitive:
		<pre style="font-size: 32px;">
		data Primitive = Note Dur Pitch
			       | Rest Dur
		</pre>
		Type "Music" consists of Primitive events glued together
			sequentially (w/ operator :+:)
			or in parallel (with operator :=:),
			or tagged with some contextual control information.
		<pre style="font-size: 32px;">
data Music a = Prim (Primitive a)       -- primitive value
	     | Music a :+: Music a      -- sequential composition
	     | Music a :=: Music a      -- parallel composition
	     | Modify Control (Music a) -- modifier
		</pre>
		So the different constructors of Music are Prim, (:+:), (:=:),
		and Modify. 

		A function "play" uses defaults to perform some conversions:
		<pre style="font-size: 32px; white-space: pre-line;">
			Music ==> to Music1 (non-parameterized) ==> [MEvent] ==> [MidiMessage]
		</pre>
		The final MidiMessage list is then sent to a MIDI output.
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_example">
	<h3>Euterpea &mdash; A short example</h3>
		<div style="text-align: left;">
			To play one or a few simple notes:
			<pre style="font-size: 32px; white-space: pre-line;">
				import Euterpea
				c :: Octave -> Dur -> Music Pitch
				play $ c 4 qn
				mapM (\octave -> play $ c octave qn) [0 .. 8]  -- Play C notes.
			</pre>
			Here is a slightly more complex: a basic version of Fr√®re Jacques (from HSoM).

			<pre style="font-size: 32px; white-space: pre-line;">
			twice m = m :+: m
			fj1, fj2, fj3, fj4, fjNotes, fj :: Music Pitch
			fj1 = c 4 qn :+: d 4 qn :+: e 4 qn :+: c 4 qn
			fj2 = e 4 qn :+: f 4 qn :+: g 4 hn
			fj3 = g 4 en :+: a 4 en :+: g 4 en :+: f 4 en :+: e 4 qn :+: c 4 qn
			fj4 = c 4 qn :+: g 3 qn :+: c 4 hn
			fjNotes = twice fj1 :+: twice fj2 :+: twice fj3 :+: twice fj4
			fj = Modify (Tempo 4) $ Modify (Instrument AcousticGrandPiano) fjNotes

			play :: Performable a => Music a -> IO ()
			play fj
			</pre>
		</div>
		<aside class="notes">
			Converting Fr√®re Jacques to a round is left as an exercise.
		</aside>
	</section>

	<section id="euterpea_percussion">
	<h3>Euterpea &mdash; Percussion</h3>
		<div style="text-align: left;">
			Percussion notation is different in scores, in MIDI, &amp; Euterpea.
			Here is percussion staff notation for the
			"<a href="http://en.wikipedia.org/wiki/Amen_break">Amen Break</a>"
			(<a href="https://upload.wikimedia.org/wikipedia/en/8/80/The_Amen_Break%2C_in_context.ogg">
			play</a>),
			a famous drum solo.
			Note: Different lines represent instruments, not pitches.
			<div style="text-align: center;">
			<img src="https://upload.wikimedia.org/wikipedia/commons/7/7e/Amen_break_notation.png"
				align="center"
				border="1"
				width="50%"
				alt="Percussion staff for the Amen Break"/>
			</div>
			<pre style="font-size: 28px;">
data Beat = Beat { bDur :: Dur, bHeard :: Int, bAcc :: Int }
type Beats = [Beat]
infixr 6 .+.
infixr 7 .*.
(.*.) n   bs  = concat $ replicate n bs
(.+.) bs1 bs2 = bs1 ++ bs2

beats2m :: PercussionSound -> Beats -> Music Pitch
beats2m percInstr [] = rest 0
beats2m percInstr (Beat { bDur=d, bHeard=h, bAcc=a } : beats)
    = m0 :+: (beats2m percInstr beats)
        where m  = Modify (Instrument Percussion) $ perc percInstr d
              m0 = case (h,a) of
                        (0, _) -> rest d  -- Silent "beat"
                        (1, 0) -> m       -- Unaccented beat
                        (1, 1) -> Modify (Phrase [Dyn (Accent 1.5)]) m
instrB = AcousticBassDrum
mkBeat d h a = [Beat { bDur = d, bHeard = h, bAcc = a }]
qns = mkBeat qn 0 0; ens =  mkBeat en 0 0; enb = mkBeat en 1 0; snb = mkBeat sn 1 0
-- amen1b represents the first measure for one instrument (Bass Drum).
amen1b = beats2m instrB $ 2.*.enb .+. qns .+. ens .+. 2.*.snb .+. qns</pre>
		</div>
		<aside class="notes">
		    <ul>
			<li> In addition to the percussion staff, above, drum tablature is sometimes used:
				<pre style="font-size: 28px; white-space: pre-line;">
					C |----------------|----------------|----------------|----------X-----|
					R |x-x-x-x-x-x-x-x-|x-x-x-x-x-x-x-x-|x-x-x-x-x-X-x-x-|x-x-x-x-x---x-x-|
					S |----o--o-o--o--o|----o--o-o--o--o|----o--o-o----o-|-o--o--o-o----o-|
					B |o-o-------oo----|o-o-------oo----|o-o-------o-----|--oo------o-----|
					->|1 + 2 + 3 + 4 + |1 + 2 + 3 + 4 + |1 + 2 + 3 + 4 + |1 + 2 + 3 + 4 + |</pre>
			<li> If polyrhythms are to be added somewhere, here's a
				<a href="https://ask.audio/articles/music-theory-4-jazz-techniques-for-electronic-composers/p3#article">
					nice image
				</a>
		    </ul>
		</aside>
	</section>

	<section id="euterpea_performance">
		<h3>Euterpea &mdash; Creating a Performance</h3>
		<div style="text-align: left;">
		If we replace play with the more explicit version
		<pre style="font-size: 32px;">
playA :: (ToMusic1 a, Control.DeepSeq.NFData a)
		=> PMap Note1 -> Context Note1 -> Music a -> IO()</pre>
		then we need to supply some more information,
		such as how to interpret note attributes (e.g., Pizzicato)
		and phrase attributes (e.g., Crescendo).
		<pre style="font-size: 32px;">
data Context a = Context { cTime :: PTime,          cPlayer :: Player a
			 , cInst :: InstrumentName, cDur    :: DurT
			 , cPch  :: AbsPitch,       cVol    :: Volume
			 , cKey  :: (PitchClass, Mode)
			 }
data Player a = MkPlayer { pName        :: PlayerName   -- ID for selection
			 , playNote     :: NoteFun a    -- Interp. notes
			 , interpPhrase :: PhraseFun a  -- Interp. phrases
			 -- , notatePlayer :: NotateFun -- Removed.
			 }</pre>
		The PMap ("Player Map") mentioned above tells Euterpea which Player to use
		for which instrument.
		</div>
		<aside class="notes">
			<pre style="font-size: 32px; white-space: pre-line;">
			type Performance = [ Event ]
			data MEvent = MEvent { eTime, eInstr, ePitch, eDur, eVol, eParams :: [ Double ] }
							deriving (Show, Eq, Ord)
			perform :: PMap a -> Context a -> Music a -> Performance  -- See p. 138 of HSoM
			type NoteFun a = Context a -> Dur -> a -> Performance
			type PhraseFun a = PMap a -> Context a -> [PhraseAttribute] -> Music a -> (Performance, DurT)
			type NotateFun a = ()
			The PMap is a map from PlayerName (String) to Player (a means of rendering sound & score).
			type PMap a = PlayerName -> Player a
			There is a similar map for channels:
			type ChannelMap = [ (InstrumentName, Channel) ]
			type ChannelMapFun = InstrumentName -> ChannelMap -> (Channel, ChannelMap)</pre>
		</aside>
	</section>

	<section id="euterpea_phraseAttribute">
		<h3>Euterpea &mdash; A Simple Phrase Attribute</h3>
		<div style="text-align: left;">
		Let's look at a function to implement the core part
			of one of the simplest phrase attributes, Crescendo,
		which causes the volume of notes to grow over the lifetime of a phrase.
		The function defined below modifies the volume of each note
		(MEvent, actually) in a Performance, based on the timing of the note
		within the performance
		<pre style="font-size: 32px;">
myPasHandler :: PhraseAttribute -> Performance -> Performance
myPasHandler (Dyn (Crescendo x)) pf = boostVolsBy x pf
    where t0 = eTime (head performance)
	perfDur :: Dur
	perfDur =  sum $ map eDur performance
	propTime :: PTime -> Rational
	propTime t = (t - t0) / perfDur
	propVolDelta :: PTime -> Rational
	propVolDelta t = x * (propTime t)
	newVol t v = round((1 + (propVolDelta t)) * (fromIntegral v))
	boostMEventVol (e@MEvent {eTime = t, eVol = v})
		= e { eVol = trace ("Vol=" ++ show (newVol t v))
				   (newVol t v)
		}
	boostVolsBy :: Rational -> [MEvent] -> [MEvent]
	boostVolsBy x pf = map boostMEventVol pf

myPasHandler pa                    pf = defPasHandler pa pf</pre>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_ragtimify">
		<h3>Euterpea &mdash; The "Ragtimify" Use Case</h3>
		<div style="text-align: left;">
		Ragtime pieces (think of "The Entertainer"
		<a href="https://www.youtube.com/watch?v=uaU4Yg6IffQ">[play]</a>)
		often have a baseline that alternates between chords and notes or pairs.
		This gives the ragtime piece it's characteristic pulse.
			<div style="text-align: center;">
			<img src="http://ragpiano.com/misc/somesyn.gif"
				align="center"
				border="1"
				width="75%"
				alt="Score of ragtime music sample"/>
			</div>
		Suppose have a piece of music with chords in its baseline,
		and you want to have a Player output a ragtime version.
		Or you want to write a function that takes a Music argument
		and outputs a ragtime version.
		You might hope to first find the Chord objects by....
		<br/><br/>
		But if your music is written in Euterpea, there are no "Chord objects".
		Because of how Music is defined, the chords are not explicitly
		recorded as such.
		Instead, they're recorded as something like
		<pre style="font-size: 32px;">
		(note1 :=: (note2 :=: (note3 :=: note4)))
		</pre>
		So one drawback of the simplicity of the internal representation used
		is that extracting structure from the piece later becomes challenging.
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_soundscape">
		<h3>Euterpea &mdash; Creating Other Sounds</h3>
		<div style="text-align: left;">
		Advanced: Euterpea also supports more general sound creation using Arrows
		(see Control.Arrow).
		<pre style="font-size: 32px;">
(>>>)          :: SF a b -> SF b c -> SF a c -- Left-to-right composition
(&lt;&lt;&lt;) :: SF b c -> SF a b -> SF a c -- Right-to-left composition
z &lt;- sigFunc -&lt; (x, y)		    -- Signal function</pre>
		<pre style="font-size: 32px;">
{-# LANGUAGE Arrows #-}
module Euterpea.Examples.SigFuns where
import Euterpea
import Control.Arrow ((>>>),(&lt;&lt;&lt;),arr)

s4 :: Clock c =>; SigFun c () Double
s4 = proc () ->; do
       f0  &lt;- oscFixed 440   -&lt; ()
       f1  &lt;- oscFixed 880   -&lt; ()
       f2  &lt;- oscFixed 1320  -&lt; ()
       outA -&lt; (f0 + 0.5*f1 + 0.33*f2) / 1.83

vibrato :: Clock c => Double -> Double -> SigFun c Double Double
vibrato vfrq dep = proc afrq -> do
  vib  &lt;- osc tab1  0 -&lt; vfrq
  aud  &lt;- osc tab2  0 -&lt; afrq + vib * dep
  outA -&lt; aud

-- type AudSF a b = SigFun AudRate a b
s5 :: AudSF () Double
s5 = constA 1000 >>> vibrato 5 20</pre>
		</div>
		<aside class="notes">
		<ul>
			<li> Arrows are like Monads, but they parameterize both input and (output) value.
			<li> proc is used to define an Arrow just like lambda defines a function.
			<li> do within an Arrow provides Arrow-related syntactic sugar,
				just like do within a Monad provides Monad-related syntactic sugar.
			<li> The operator (-&lt;) can be pronounced "(first order) arrow tail".
			<li> There's another operator, (-&lt;&lt;), or "(higher order) arrow tail".
		</ul>
		</aside>
	</section>

	<section id="euterpea_instruments1">
		<h3>Euterpea &mdash; Custom Instruments (1/2)</h3>
		<div style="text-align: left;">
			<pre style="font-size: 32px;">
data Instrument Name = AcousticGrandPiano -- See p. 35 of HSoM
		     | BrightAcousticPiano
		     | ...
		     | Custom String
		     deriving (Show, Eq, Ord)</pre>
			This can be used as follows (see Chapter 19 of HSoM)
			<pre style="font-size: 32px;">
    myMandolinName :: InstrumentName -- Or myFlugelhorn or myUkulele
    myMandolinName = Custom "My Mandolin"
    type Instr a = Dur -> AbsPitch -> Volume -> [Double] -> a</pre>
			This is commonly used with the type variable a being
			"<font color="#0000ff">Instr (AudSF () Double)</font>".
			The list of parameters ([Double], above) are handled as determined by the instrument designer.
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_instruments2">
		<h3>Euterpea &mdash; Custom Instruments (2/2)</h3>
		<div style="text-align: left;">
			Let's use the vibrato function defined earlier as a starting point.  (See Fig. 19.4 in HSoM.)
			<ul>
				<li>Step #1: Convert a signal function into an instance of type Instr.
					For example, using <em>vibrato</em>,
					<pre style="font-size: 32px;">
myMandolin :: Instr (AudSF () Double)
-- Dur -> AbsPitch -> Volume -> [Double] -> (AudSF () Double)
myMandolin dur ap vol [vfrq, dep] =
    proc () -> do
	vib &lt;- osc tab1 () -&lt; vfrq
	aud &lt;- osc tab2 () -&lt; apToHz ap + vib * dep
	outA -&lt; aud		</pre>
				<li>Step #2: Connect the instrument name to the instrument definition.
					<pre style="font-size: 32px; white-space: pre-line;">
					type InstrMap a = [(InstrumentName, Instr a)]
					myInstrMap :: InstrMap (AudSF () Double)
					myInstrMap = [(myMandolinName, myMandolin)]
					</pre>
				<li>Step #3: Use the Euterpea function <em>renderSF</em>
					<pre style="font-size: 32px;">
renderSF :: (Performable a, AudioSample b, Clock c)
	=> Music a -> InstrMap (SigFun p () b)
	    -> (Double, SigFun p () b)	</pre>
				<li>Finally:
					<pre style="font-size: 32px; white-space: pre-line;">
					mandolinMelody = instrument myMandolinName $ <font color="#0000ff" weight="bold">...music...</font>
					(dur, sigFun) = renderSF mandolinMelody myInstrMap
					main = outFile "mandolinMelody.wav" dur sigFun
					</pre>
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_codingStandards">
	<h3>Euterpea &mdash; Some music coding standards</h3>
		<div style="text-align: left;">
		<ol>
		<li> <b>Represent compositions as concatenations of smaller sub-compositions ("pieces")
				in a regular way, such as by instrument and measure(s).</b>
			<ul>
				<li> Consider naming the pieces to reflect the structure of this decomposition.
				<ul>
					<li> E.g., sonata_violin_1_4 could contain measures 1 through 4.
				</ul>
				<li> If a value contains multiple measures, consider putting each measure
					on a separate line.
				<li> Identify and extract duplicated subexpressions and other structures.
				<ul>
					<li> If lyrics are tied to the subexpression,
						consider using them in the name of the subexpression.
				</ul>
				<li> Identify nearly-duplicated subexpressions, and use functions
					to extract the commonality.
			</ul>
		<br/>
		<li> <b>Perform validation tests:</b>
			<ul>
				<li> Validate that all pieces have the expected duration.
				<li> Validate that all expected instruments are present.
			</ul>
		<br/>
		<li> <b>Perform live testing:</b>
			<ul>
				<li> Listening to compositions will help detect some issues.
				<li> Play melodies in parallel to detect differences/intervals.  (Discussion: XOR impl. issues)
			</ul>
		<br/>
		<li> <b>Derive metrics to be used in testing:</b>
			<ul>
				<li> Just as images can be associated with color histograms,
					short segments of music can be associated (via FFTs) with frequency histograms.
			</ul>
		</ol>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_other">
		<h3>Euterpea &mdash; Other Info</h3>
		<div style="text-align: left;">
		<ul>
			<li> Chapter 17 of HSoM introduces
				Arrow-based Functional Reactive Programming (FRP) 
				via FRP.UISF.
			<ul>
				<li> Good place to learn more:
				Daniel Winograd-Cort's
				<a href="https://github.com/dwincort/UISF/tree/master/FRP/UISF/Examples">
				UISF Examples
				</a> on github.
			</ul>
			<li> Many other MPLs have Haskell interfaces,
				allowing communication between them &amp; Euterpea.
			<li> <a href="http://music-suite.github.io/docs/api/">
				Haskell Music Suite</a>:
				a slick music DSL inspired by Euterpea and others.
				<ul>
					<li> Focused on score representation
					<li> Does not support soundscapes
					<li> Has a "back end" that supports printing tonal music via LilyPond
					<li> Also has a type called Music, but it's different from Euterpea's: 
				<pre style="font-size: 32px;">
type StandardNote =
  (PartT Part
    (ColorT
      (TextT
        (TremoloT
          (HarmonicT
            (SlideT
              (ArticulationT Articulation
                (DynamicT Dynamics
                  [TieT
                    Pitch]))))))))

type Music = Score StandardNote</pre>
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_csound">
	<section id="csound">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_euterpea">&#x25c1;</a>
			Csound
			<a href="#/section_chuck">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
			Csound is an opcode-based language (think assembler).  The user can:
			<ul>
				<li> Define customized instruments
				<ul>
					<li> The instruments are basically waveforms, but can be custimized to sound like actual instruments.
				</ul>
				<li> Combine them to create music
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="csound_example">
		<h3>Csound &mdash; A Simple Example</h3>
		<div style="text-align: left;">
		Here is a simple example from the documentation:
		<pre style="font-size: 32px;">
&lt;CsoundSynthesizer>
&lt;CsOptions>
&lt;/CsOptions>
&lt;CsInstruments>
sr = 44100		&lt;== Sample rate (Hz) for audio signals & vars
ksmps = 128		&lt;== Sample rate per control-block, e.g., mouse
nchnls = 2		&lt;== # of audio channels.  Two for stereo.
0dbfs = 1		&lt;== Max output in dBs before clipping

instr 2
kFreq expon 100, 5, 1000    ; kFreq set to the output of expon(ential)
aOut  oscili 0.2, kFreq, 1  ; aOut set to the output of 'oscil' 
	outvalue "freqsweep", kFreq
	outs aOut, aOut
endin
&lt;/CsInstruments>
&lt;CsScore>
f 1 0 1024 10 1	; this function table contains the sine information
i 2 0 5 	; the instrument is called at t=0 &amp; plays for 5 sec.
e
&lt;/CsScore>
&lt;/CsoundSynthesizer></pre>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="csound_language">
		<h3>Csound &mdash; Other Language Features</h3>
		<div style="text-align: left;">
			<ul>
				<li> Instrument parameters: All instruments have 3 fixed params:
					<ul>
						<li> Instrument #
						<li> Start time
						<li> Duration
					</ul>
					<pre style="font-size: 32px;" width="100%;">
instr 1			   &lt;== This takes 2 extra params: amp &amp; freq.
aSine poscil3 p4, p5, 1;   &lt;== p4 = 4th param; p5 = 5th param
	outs aSine, aSine  &lt;== One output for each channel
endin										</pre>
				<li> Similarly, function tables can also take extra params.
				<li> We've got if statements and loops!
					<pre style="font-size: 32px;">
instr 1
iGreetingCount = 0
    loop:		   &lt;== Any label
	iGreetingCount = iGreetingCount + 1
	prints "Hello world #%i\n", iGreetingCount
    if (iGreetingCount &lt; 5) igoto loop
endin</pre>
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="csound_other">
		<h3>Csound &mdash; Other info</h3>
		<div style="text-align: left;">
			<ul>
				<li> <a href="http://blue.kunstmusik.com/">Blue</a>
					is a composition environment for Csound.
				<li> 
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_chuck">
	<section id="chuck">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_csound">&#x25c1;</a>
			ChucK
			<a href="#/section_puredata">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes">
		<ul>
			<li> At one point, there was a Coursera course on ChucK, "ChucK 101".  It's now 404.
		</ul>
		</aside>
	</section>

	<section id="chuck_hellosinewave">
		<h3>ChucK &mdash; Hello Sine Wave</h3>
		<div style="text-align: left;">
			ChucK sends audio to the speakers using a Digital-to-Audio Converter (DAC) denoted by dac.<br/>
			Here is a script that plays a 220 Hz sine wave for 5 seconds.
		<pre style="font-size: 32px;">
	&lt;&lt;&lt; "Hello, sine wave" >>>
	SinOsc s => dac;
	0.6 => s.gain;
	220 => s.freq;
	5::second => now;
		</pre>
		In this script:
		<ul>
			<li> &lt;&lt;&lt;Stuff inside the angled quotes>>> is  evaluated and printed.
			<li> The Sinusoidal Oscillator type, SinOsc, has "gain" (i.e., volume) and "freq" (i.e., pitch) properties.
			<li> The '=>' symbol is called the "chuck" operator, since it "throws" or "chucks" a value or stream to its destination.
			<li> Sending a duration to "now" causes time to advance.  This streams output to the dac to create sound.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="chuck_moreinfo">
		<h3>ChucK &mdash; More Info</h3>
		<div style="text-align: left;">
		<ul>
			<li> Musical notes are be called by their MIDI Note Numbers, &amp; converted to freqs by Std.mtof().
			<li> A 3-note chord can be represented by an array of SinOsc objects: SinOsc chord[3];
			<li> ChucK uses the whimsical terms "shreds" and "spork" for processes and forks.
			<ul>
				<li> Scripted and compiled plug-ins are called Chugens and ChuGins.
			</ul>
			<li> Different instruments are put in different "shreds".  Events communicate between shreds.
			<li> To emulate rests, have time advance in a static scope without audio streams.
				<ul>
					<li> Notes placed in function calls are in a different static scope.
				</ul>
			<li> For stereo, dac has fields called <tt>.left</tt> and <tt>.right</tt>.
				<ul>
					<li> For quadraphonic sound, use the <tt>.chan</tt> field.
				</ul>
			<li> ChucK can run in "live performance mode", where a script is updated while running.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="chuck_echo">
		<h3>ChucK &mdash; Echo Script</h3>
		<div style="text-align: left;">
		Here is a simple "echo" script that reads from a microphone,
			then echoes a slightly delayed and muted version to the speakers.  It uses a built-in Audio-to-Digital Converter (ADC) called adc. 
		<pre style="font-size: 32px;">
	// Feedback setup
	adc => Gain g => dac;
	g => Gain feedback => DelayL delay => g;

	0.75::second => delay.max => delay.delay;
	0.5 => feedback.gain;  // Note: gain &lt; 1.
	0.75 => delay.gain;
	while (true) 1::second => now;
		</pre>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="chuck_instrument">
		<h3>ChucK &mdash; Instrument Modeling</h3>
		<div style="text-align: left;">
		Here's a simplified version of a plucked string, modified from the book
			<a href="http://www.amazon.com/Programming-Musicians-Digital-Artists-Creating/dp/1617291706/">
				Programming for Musicians and Digital Arists: Creating music with ChucK
			</a>.
		<pre style="font-size: 32px;">
	// Karplus-Strong model of a plucked string
	Impulse imp => Delay plucked => dac;
	plucked => plucked;   // Feedback 
	441.0::samp => plucked.delay; // Sample rate
	0.98 => plucked.gain; // Round-trip gain &lt; 1
	1.0 => imp.next;      // "Pluck" impulse
	5.0::second => now;   // The string resonates</pre>
		<ul>
			<li> Note the feedback line that connects plucked to itself,
					reflecting how the action of a plucked string is dependent
					on its action at previous moments in time.
		</ul>
		</div>
		<aside class="notes">
			Instrument modeling was pulled into ChucK from the earlier
			<a href="https://ccrma.stanford.edu/software/stk/">Synthesis ToolKit in C++</a>.
		</aside>
	</section>

	<section id="chuck_other">
		<h3>ChucK &mdash; Other info</h3>
		<div style="text-align: left;">
		The Good &amp; The Bad
			<ul>
			<li> What ChucK does well: Signal processing and musical instrument acoustic modeling.
			<li> What ChucK doesn‚Äôt do as well: Programmatic expressiveness and musical expressiveness.
			<ul>
				<li> Programmatic exp.:
						There's no support for interfaces or higher-order functions, and it‚Äôs 2016!
				<li> Musical exp.:
						The language supports abstractions for audio streams,
						but not so much for melodic composition or analysis,
						which are critical for the capturing of many musical idioms.
						(Think of two jazz musicians speaking with each other in shorthand.
						Then again, what programming environment captures this well?)
						This shortcoming is partially addressed by some open source libraries on github
							(e.g., LiCK and Chuckery), but these can only go so far in addressing
							fundamental language limitations.
				</ul>
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_puredata">
	<section id="puredata">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_chuck">&#x25c1;</a>
			Pure Data (Pd)
			<a href="#/section_supercollider">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_supercollider">
	<section id="supercollider">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_puredata">&#x25c1;</a>
			SuperCollider 3 (SC)
			<a href="#/section_strasheela">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="supercollider_language">
		<h3>SuperCollider &mdash; The Language</h3>
		<div style="text-align: left;">
		SuperCollider (named in 1993 after the cancelled Superconducting Super Collider project)
			is an OO language that supports GUI programming,
			with slightly differences between Windows, Mac, and Linux.
		It also supports plug-ins, a means of interactive programming, MIDI data,
			and communication with external devices.
		Functions are invoked via messages, as in Smalltalk.
		<pre style="font-size: 32px;">
	15.squared           // Evaluates to 225.
	[45, 13, 10].sort    // Evaluates to [10, 13, 45]
	5 pow: 8             // Same as 5.pow(8) 
	10.do({ "Hello world".postln })    // Writes to the "Post" pane.</pre>
		Caution: Binary operators are always evaluated in left-to-right order,
			so 1 + 3 * 5 yields 20, not 16.
		<br/><br/>
		Here is a brief code snippet that prints out the value of 5! ("five factorial"):
		<pre style="font-size: 32px;">
	var factorial = { | n |
		var result = 1;
		n do: { | i | result = result * (i + 1) };
		result;
	};
	factorial.(5).postln;</pre>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="supercollider_basics">
		<h3>SuperCollider &mdash; The Basics</h3>
		<div style="text-align: left;">
		SuperCollider has a client-server design, like IPython/Jupyter.
		The client's interpreter starts automatically.  A local audio server can be started with the command
		<pre style="font-size: 32px;">
		s.boot</pre>
		where the variable "s" is reserved to represent the server.
		Client-server synchronization is achieved via communication message tags
			with the intended time of execution in NTP (Network Time Protocol) format.
		<br/><br/>
		To execute a command in the IDE that comes with SC,
			highlight a section of code and type Ctrl-Enter.
		<br/><br/>
		The IDE's Help Browser is easy to use, though some entries have minimal information.
		<br/><br/>
		SuperCollider focus is on creating envelopes of sound with signal processing,
			and combining them with a family of "pattern" classes (e.g., Pbind, Pchain, Prand, etc.).
			While it's theoretically possible to emulate specific musical instruments (e.g., piano, guitar, etc.)
			in SuperCollider, it isn't commonly done.
		</div>
	</section>

	<section id="supercollider_sinewaves">
		<h3>SuperCollider &mdash; Sine Waves</h3>
		<div style="text-align: left;">
		A (non-terminating) sine wave at 440 Hz can be played at half-volume with
		<pre style="font-size: 32px; white-space: pre-line;">
		{ SinOsc.ar(440, phase: 0, mul: 0.5, add: 0) }.play;  // Keyword args</pre>
		or
		<pre style="font-size: 32px; white-space: pre-line;">
		{ SinOsc.ar(440, 0, 0.5, 0) }.play;  // Positional args</pre>
		or just
		<pre style="font-size: 32px; white-space: pre-line;">
		{ SinOsc.ar(440) }.play;  // Omitting arguments with default values</pre>
		where "ar" is the "audio rate" constructor of the SinOsc class.
		The sine wave can be stopped with Ctrl-&lt;period>.
		All the parameters above can be omitted, which will cause default values to be used.
		An important class to become familiar with is UGen, the abstract superclass of all "unit generators".
		These unit generators represent signals.  Predefined examples include:
		<ul>
			<li> Impulse, a class that represents a simple sound;
			<li> LFSaw, a class that represents a low-frequency sawtooth oscillator (cf. SinOsc);
			<li> PMOsc, a class that represents a phase modulation oscillator (cf. SinOsc);
			<li> EnvGen, which wraps another signal with an "envelope";
			<li> Latch, which wraps another signal with an all-or-nothing filter.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="supercollider_complex">
		<h3>SuperCollider &mdash; A More Complex Example</h3>
		<div style="text-align: left;">
		Lastly, here is a short piece that creates a cascade of random pitches
			that varies more quickly when the mouse is moved to the right-hand side of the IDE window.
		<pre style="font-size: 32px; ">
{
	var freq, latchrate, index, ratio, env, speed = 9;
	speed = MouseX.kr(2, 20);
	latchrate = speed * 1.61803399;
	index = Latch.kr(
		LFSaw.kr(latchrate, mul: 4, add: 8),
		Impulse.kr(speed)
	);
	freq = Latch.kr(
		LFSaw.kr(latchrate, mul: 36, add: 60),
		Impulse.kr(speed)
	).round(1).midicps;
	ratio = 2.01;
	env = EnvGen.kr(Env.perc(0, 2/speed), gate: Impulse.kr(speed));
	Out.ar(0, PMOsc.ar([freq, freq * 1.5],
		[freq * ratio, freq * 1.5 * ratio],
		index,
		mul: env * 0.5)
)}.play</pre>
		</div>
		<aside class="notes">
		When SC was named, the SSC had recently been cancelled by a budget cut.
		The musical language SuperCollider (SC) had a similarly grand vision
			(real-time music synthesis within a garbage-collected language),
			and its creater was skeptical of its long-term success.
		Luckily, SuperCollider has enjoyed greater success than its physics namesake.
		SuperCollider has a bunch of basic types (Integer, Float, Char, String, Symbol,
			Point, Array, Event, Function)
		</aside>
	</section>

	<section id="supercollider_overtone">
		<h3>SuperCollider &mdash; Overtone and Leipzig</h3>
		<div style="text-align: left;">
			<a href="http://overtone.github.io/">Overtone</a> is a Clojure-based language
			wrapping SuperCollider,
			<a href="https://github.com/ctford/leipzig">Leipzig</a>
			is a composition lib used with Overtone, and 
			<a href="https://github.com/ctford/leipzig-template/tree/master/src/leiningen">Leiningen</a>
			is a Leipzig template library.
			Below is code from a song called 
			<a href="https://www.snip2code.com/Snippet/176938/Tuesday---written-with-Overtone-and-Leip">
			"Tuesday"</a>.
			<pre style="font-size: 32px;">
(definst metallia [freq 440 dur 1 volume 1.0]
    (-> (sin-osc freq (sin-osc 1))
	(+ (sin-osc (* 1/2 freq) (sin-osc 1/3)))
	(clip2 (mul-add (saw 1/4) 0.2 0.7))
	(* (env-gen (adsr 0.03 0.6 0.3) (line:kr 1 0 dur) :action FREE))
	(* 1/4 volume)))

(defn minor [chord] (update-in chord [:iii] (scale/from -1/2)))

(def melody
    (->>
	(phrase [2/3 13/3 5/3 9/3 1/3 2/3 13/3 2/3 13/3]
		[  1    2   1   0   0   1    2   3    0])
	(where :pitch scale/raise)
	(where :part (is :melody))))</pre>
			<p>
				See <a href="https://github.com/overtone/overtone/tree/master/src/overtone/examples">Overtone examples</a>
				for more sample code.
				Note the three distinct functions above:
			</p>
			<ul>
				<li> def &mdash; What you'd expect.  The operator "->>" is a Clojure macro.
				<li> defn &mdash; Same as def, but this adds metadata to the defined var.
				<li> definst &mdash; Defines an instrument.
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_strasheela">
	<section id="strasheela">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_supercollider">&#x25c1;</a>
			Strasheela (Honorable Mention)
			<a href="#/section_resources">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		Strasheela is an MPL that lets the user describe constraints
		(e.g., rhythmic, melodic, and harmonic) on a music composition
		via user-defined "containers".
		Strasheela then finds one or more compositions that satisfies these constraints,
		presuming that they are satisfiable.
		<br/><br/>
		Strasheela was writting by Torsten Anders for his dissertation,
		but hasn't seen significant developmenbt since 2012. 
		It's implemented in the constraint-based programming language, Oz,
		which is similar to Prolog.
		(The theme of "Oz" provides the name "Strasheela" &mdash;
		it's the name of the Scarecrow in the Russian version of The Wizard of Oz.)
		<br/><br/>
		After calling 
		<a href="http://strasheela.sourceforge.net/strasheela/doc/api/node6.html#entity378">
		Score.makeScore
		</a>,
		the output can be rendered with a choice of formats, including
		LilyPond, Csound, SuperCollider, or Common Lisp Music (CLM).
		</div>
		<aside class="notes" >
			<ul>
				<li> Score constructors, score accessors, score transformers.
				<li> Predefined constraints.
				<li> Has a data type called finite domain (FD) integers.
				<li> Hasn't been worked on since 2012 &mdash; You could say there's a resource constraint.
			</ul>
		</aside>
	</section>

	<section id="strasheela_constraints">
		<h3>Strasheela &mdash; Constraints</h3>
		<div style="text-align: left;">
			Example of a constraint called RestrictMelodicInterval.
			(<a href="http://cmr.soc.plymouth.ac.uk/tanders/publications/TorstenAnders-MOZ2004.pdf">
			2004 paper
			</a>)
			<br/>
			The constraint: Consecutive notes must be separated by at most a perfect fifth (i.e., 7 semitones).
			<pre style="font-size: 32px;">
proc {RestrictMelodicInterval Note1}
    Note2 = {Note1 getTimeAspectPredecessor($)}
in
    7 >=: {FD.distance {Note1 getPitch($)} {Note2 getPitch($)}}
end</pre>
			And here is this rule being applied:
			<pre style="font-size: 32px;">
{MyScore
    forAll(RestrictMelodicInterval
	test:fun {$ X}
	    {X isNote($)} andthen
	    {X hasTimeAspectPredecessor($)}
    end)}
}</pre>
			A typical Strasheela program can use hundreds of variables and constraints.<br/>
			Constrait order does matter.  Usually it's Timing &rArr; Melodic &rArr; Harmonic.<br/>
			A novice user should gradually increase the number of constraints to determine impact.
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="strasheela_canons">
		<h3>Strasheela &mdash; Canons</h3>
		<div style="text-align: left;">
			A <em>canon</em> is music with 2+ voices that play time-shifted copies of the same music.<br/>
			Constraints can ensure that the copies sound harmonious together.<br/>
			Classic examples: "Row, Row, Row Your Boat" and "Fr√®re Jacques".<br/>
			An "<em>accompanied canon</em>" has other non-repeating voices.<br/>
			<br/>
			Here's a short canon found in a few seconds by Strasheela.
			[<a href="https://raw.githubusercontent.com/tanders/strasheela/master/strasheela/examples/Output/03-FloridCounterpoint-Canon.mp3">play</a>]:
			<img src="https://raw.githubusercontent.com/tanders/strasheela/master/strasheela/examples/Output/03-FloridCounterpoint-Canon.preview.png"
				border="1"
				width="100%"
				alt="Score of sample canon"/>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="strasheela_flexibility">
		<h3>Strasheela &mdash; Flexibility</h3>
		<div style="text-align: left;">
			Finding solutions to a system of constraints is a standard computer programming problem.
			The challenge facing Anders in the creation of Strasheela was to provide the user
			flexibility while at the same time making efficient use of computer resources.
			<br/><br/>
			Flexibility:
			<ul>
				<li> Strasheela has many pre-defined pattern constraints.
					An example of a simple numerical constraint would be to ensure
					that the largest number in a list appears only once,
					or that all items in a list are distinct from each other.
				<li> The user can apply their own Lindenmayer system (i.e., generative grammar).
				<li> Constraints can be applied to containers, which can be nested hierarchically.
					So you can have a one-measure container nested inside a three-measure container
					inside a five-measure container.
					And these can all have different constaints applied to them.
					You can group together different voices playing concurrently,
					or put a constraint on different repetitions of a single voice.
					(However, the nesting of score containers must be fully determined
					before the search for a constraint satisfaction solution begins.)
				<li> Constraints can be made into "soft constraints" that are more like preferences.
					The user can specify priority between rules, and can even specify
					that a given constraint not be violated more than a pre-chosen number of times.
					(For example, you might allow only a few intervals between consecutive notes exceed one octave.)
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="strasheela_efficiency">
		<h3>Strasheela &mdash; Efficiency</h3>
		<div style="text-align: left;">
			Efficiency:
			<ul>
				<li> Strasheela allows the user to define what search strategy is used,
					according to the constraint problem.
					A well-chosen "distribution" strategy can allow for work on one sub-problem
					to be shut down once parameters have been found that are good enough,
					thereby allowing the program to continue applying resources
					where they are most effective.
				<li> An effort is made to to determine early on that no solutions will be found
					in a particular domain, rather than searching through that domain and coming up empty.
					(In more formal terms, constraint propagators are used to prune the search space.)
				<li> Strasheela allows for the use of a memory-saving technique called adaptive recomputation.
					Unfortunately, there's not a good explanation of this approach outside the source code.
			</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_resources">
	<section id="resources">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_strasheela">&#x25c1;</a>
			Resources
			<a href="#/appendix">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		<p><b>Music &amp; Music Theory</b></p>
			<ul>
				<li> <a href="http://www.amazon.com/Jazz-Theory-Book-Mark-Levine/dp/1883217040">
					The Jazz Theory Book
					</a>, by Mark Levine
				<li> <a href="http://postmodernjukebox.com/courses/Ragtimify.pdf">
					Ragtimify</a>: a book on converting scores to Ragtime
				<li> Song databases: 
					<a href="http://labrosa.ee.columbia.edu/millionsong/">The Million Song Dataset</a>
						| <a href="https://www.hooktheory.com/theorytab/guide">The Theorytab database</a>
						| <a href="http://www.bandmusicpdf.org/">Band music</a>
						| <a href="http://imslp.org/wiki/">International Music Score Library Project</a>
						| <a href="http://www.gutenberg.org/browse/categories/4">Project Gutenberg</a>
				<li> <a href="http://bach.nau.edu/clavier/nature/fugues/Fugue02.html">
					Visualization of music by Bach and others
					</a>
			</ul>
		<p><b>Music Programming &amp; Analysis</b></p>
			<ul>
				<li> Cheatsheets:
					<a href="https://github.com/overtone/overtone/raw/master/docs/cheatsheet/overtone-cheat-sheet.pdf">Overtone</a>
				<li> <a href="http://www.musicainformatica.org/topics/music-n.php">History</a>
					of the Music-N family of MPLs
				<li> <a href="http://www.link.cs.cmu.edu/melisma/">The Melisma Music Analyzer</a>
				<li> <a href="http://soareschen.github.io/harmtrace-slides/#1">Functional
					Modelling of Musical Harmony</a>
				<li> <a href="http://theses.gla.ac.uk/2353/">Analysis
					of musical structures using monadic parser combinators</a>
			</ul>
		<p><b>Colophon</b></p>
			<ul>
				<li> <a href="https://github.com/hakimel/reveal.js">Documentation on reveal.js</a>,
					used to create this deck.
			</ul>
		</div>
		<aside class="notes">
			<ul>
				<li> <a href="http://www.mat.ucsb.edu/res_proj7.php">Sonification
					of the cosmic microwave background</a>
				<li> A comparison of software to convert MIDI files to scores:
					<a href="http://www.skytopia.com/project/articles/notation.html">link</a>,
					though it doesn't include
					<a href="http://midisheetmusic.sourceforge.net/">midisheetmusic</a>
			</ul>
		</aside>
	</section>
</section>

<section id="section_appendix">
	<section id="appendix">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_resources">&#x25c1;</a>
			Appendix
			<a href="#/title">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="appendix_advice">
		<h3>Appendix A &mdash; Advice</h3>
		<div style="text-align: left;">
		<ul>
			<li> Volume.
				<ul>
					<li> Programs that don't explicitly set volume might by default
						play at the loudest possible volume.
					<li> Sudden changes in soundscape volume can result in clicks.
						These can be resolved by adding envelopes to modulate the volume.
				</ul>
			<li> Note that pitch numbering starts at C in each octave, not A.
				<ul>
					<li> For example, the pitch one semitone below C4 is not B4, but B3.
				</ul>
			<li> The MIDI file format has fixed-range values.
				For example, MIDI notes range from 0 to 127, which can fit in 7 bits.
				If, say, as the result of a transposition, a note is given a value above 127,
				it will be truncated, and result in a lower pitch than expected.
			<li> This presentation was made using reveal.js.
				If you want to attempt to modify the vertical placement of slides
				on a reveal.js presentation, take a look at the layout() function in reveal.js.
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
	
	<section id="appendix_choosing">
		<h3>Appendix C &mdash; Choosing a Music Programming Language</h3>
		<div style="text-align: left;">
		If you just want to compose music, an app (e.g., Opusmodus, TODO) might make more sense
		than an MPL.
		<br/><br/>
		Here are some guidelines on which language to choose.
		(TODO: Live performance)
		<table>
			<tr><th>Language/Library</th>
				<th>Reason to choose</th>
			</tr>
			<tr><td>Euterpea</td>
				<td>
					<ul>
						<li> Benefits of pure functional programming.
						<li> Integration of tonal and soundscape music.
						<li> Haskell
							<a href="https://wiki.haskell.org/Applications_and_libraries/Music_and_sound">APIs</a>
							for Csound, SuperCollider, OpenAL/ALUT.
					</ul>
				</td>
			</tr>
			<tr><td>Csound</td>
				<td>
					<ul>
						<li> Compiler-level compatibility, due to being written in C
						<li> Inherited legacy code?
					</ul>
				</td>
			</tr>
			<tr><td>Chuck</td>
				<td>
					<ul>
						<li> Good support for instrument modeling
						<li> 
					</ul>
				</td>
			</tr>
			<tr><td>Pure Data</td>
				<td>If it's important to choose a visual programming language</td>
			</tr>
			<tr><td>SuperCollider</td>
				<td>
					<ul>
						<li> Smalltalk-like syntax
						<li> Preferred by some over Csound and Pure Data.
					</ul>
				</td>
			</tr>
			<tr><td>Strasheela</td>
				<td>Support for constraint-based composition</td>
			</tr>
		</table>
		</div>
		<aside class="notes">
		</aside>
	</section>

	<section id="appendix_ecosystems">
		<h3>Appendix E &mdash; Ecosystems</h3>
		<div style="text-align: left;">
		<ul>
			<li> Java
				<ul>
					<li> The
						<a href="http://www.oracle.com/technetwork/java/index-139508.html">Java Sound API</a>
						(<a href="https://docs.oracle.com/javase/tutorial/sound/">tutorial</a>)
				</ul>
			<br/>
			<li> Linux
				<ul>
					<li> TODO
				</ul>
			<br/>
			<li> Mac
				<ul>
					<li> <a href="https://en.wikipedia.org/wiki/Logic_Pro">Logic Pro</a> (a DAW &mdash; Mac OS X only)
					<li> <a href="https://en.wikipedia.org/wiki/Ableton_Live">Ableton Live</a> (a DAW &mdash; Mac/PC)
				</ul>
			<br/>
			<li> .NET
				<ul>
					<li> <a href="http://naudio.codeplex.com/">NAudio</a>
					<li> <a href="https://code.google.com/archive/p/midi-dot-net/">midi-dot-net</a>
				</ul>
			<br/>
			<li> Python
				<ul>
					<li> <a href="http://web.mit.edu/music21/">music21</a>:
						a toolkit for computational musicology, music theory, and generative composition.
				</ul>
		</ul>
		</div>
		<aside class="notes">
		</aside>
	</section>
</section>

</div> <!-- slides -->
</div> <!-- reveal -->

<script>
	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: true,
		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// JMC
		width: 1600,
		height: 1000,
		margin: 0.05,
		rollingLinks: true,
		slideNumber: true,

		// Optional reveal.js plugins
		dependencies: [
			{ src: 'js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/notes/notes.js', async: true }
		]
	});
</script>
</body>
</html>

<!-- Euterpea notes:
			<pre sytle="font-size: 32px;">
			playA :: (ToMusic1 a, Control.DeepSeq.NFData a)
					=> PMap Note1 -> Context Note1 -> Music a -> IO ()
					(This calls playC)
			playC :: (ToMusic1 a, Control.DeepSeq.NFData a)
					=> PlayParams -> Music a -> IO ()
					(This calls playStrict or playInf)
			playStrict :: (ToMusic1 a, NFData a)
					=> PlayParams -> Music a -> IO ()
			playStrict p m = m `deepseq`
				let x = toMidi (perfAlg p $ toMusic1 m)
				in x `deepseq` playM' (devID p) x
					(So this calls toMusic1, toMidi, and playM')
			toMusic1 :: Music a -> Music1
				has instances for: Pitch, (Pitch, Volume), Note1, AbsPitch
			toMidi:: [MEvent] -> Midi
			toMidi = toMidiUPM defUpm
			toMidiUPM :: UserPatchMap -> [MEvent] -> Midi
			playM' :: Maybe OutputDeviceID -> Midi -> IO ()
					(This calls playMidi)
			data Midi = Midi { fileType :: FileType}
							 , timeDiv :: TimeDiv
							 , tracks :: [Track Ticks]
							 }
			playMidi :: OutputDeviceID -> Midi -> IO ()
			type MidiEvent = (Time, MidiMessage)
			data MidiMessage = ANote { channel :: !Channel
									 , key :: !Key
									 , velocity :: !Velocity
									 , duration :: !Time
									 }
							 | Std Message
			type MidiEvent = (Time, MidiMessage)
			</pre>
-->

<!-- reveal.js notes:
	Setting up reveal.js:
		http://htmlcheats.com/reveal-js/reveal-js-tutorial-reveal-js-for-beginners/
	Code formatting:
		<pre><code class="hljs" data-trim contenteditable>
		</code></pre>
	Fragments:
		<p class="fragment">one fragment</p>
		<span class="fragment">another</span>
	JavaScript API:
		https://github.com/hakimel/reveal.js#api
	Links to other slides:
		<section id="languages">
		<a href="#/languages">like this</a>
	Markdown:
		Guidelines for reveal.js at https://github.com/hakimel/reveal.js#markdown
		<section data-markdown>
			<script type="text/template">
	Quote templates
		Inline: <q cite="http://foo/bar/baz.html">&ldquo; Lorem ipsum &rdquo;</q>
		Blockquote:
			<blockquote cite="http://foo/bar/baz.html">
				&ldquo; Lorem ipsum .&rdquo;
			</blockquote>
	State:
		Global state:
			Setting data-state="foo" on a slide => "foo" is added as a class to the doc element on open.
		Events:
			See documentation.
	Style changes
		style="font-size: 72px;"
-->
