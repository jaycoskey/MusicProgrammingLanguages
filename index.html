<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Music Programming Languages</title>
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
	<meta name="author" content="Jay Coskey">
		<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/beige.css" id="theme">

	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement( 'link' );
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match( /print-pdf/gi ) ? 'css/pdf.css' : 'css/paper.css';
		document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
	<script src="js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
</head>

<body>
<div class="reveal">
<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">

<section id="title">
		<h1>Music Programming Languages</h1>
		<h3>Creating and Analyzing Tonal Music and Soundscapes</h3>
		<p align="center">Jay Coskey</p>
		<p align="center">2016-05-04</p>
		<b>
		<pre style="background-color: #d0ffd0; font-size: 48px;">
  Use N or &lt;space&gt; to advance to the next slide.
  Use P to return to the previous slide.
  Use &lt;Esc&gt; to view an overview of all slides.
  Use ? to view a list of all keyboard commands.
		</pre>
		</b>
</section>

<section id="section_introduction">
	<section id="introduction">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/title">&#x25c1;</a>
			Introduction
			<a href="#/euterpea">&#x25b7;</a>
		<aside class="notes"/>
	</section>

	<section id="intro_domain">
		<h3>The Domain of Music</h3>
		<div style="text-align: left;">
		<ul>
			<li> Tonal Music vs. Soundscapes
				<ul>
					<li> For example: "Greensleeves", or "Mary Had a Little Lamb"
				</ul>
			<li> Some Dimensions of Tonal Music
				<ul>
					<li> The THX Sound Effect, "Deep Sound"
				</ul>
			<li> Music Data Mining
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="intro_dimensions">
		<h3>Some Dimensions of Tonal Music</h3>
		<div style="text-align: left;">
		<ul>
			<li> Acoustics, instruments, composition, play/record, visualization, psychology
			<li> Melodic music
			<ul>
				<li> Time: Rhythm
				<li> Freq: Choice of temperament, scales, keys, chords, melodies
				<li> Human-readable formats: Traditional, extreme, national, etc.
				<li> Computer formats: ABC, LilyPond, MusicXML, MIDI, etc. (incl. lyrics)
				<li> Tools: Scorewriters (e.g., MuseScore, Finale, Sibelius)
			</ul>
			<li> Soundscapes sound & Digital Audio Workstations (DAWs) 
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="intro_music_data_mining">
		<h3> Music data mining</h3>
		<div style="text-align: left;">
		<ul>
			<li> Music corpora (e.g., Wikifonia), compression, storage, indexing, tagging
			<li> Assisted and autonomous composition, including stochastic systems
			<li> Generations of chords from melody (e.g., using HMMs)
			<li> Instrument, artist, genre, mood identification (using signal processing)
			<li> Measuring song similarity (e.g., copyright infringement), incl. phrase identification
			<li> Song search (incl. search by humming), song recommendations
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="intro_languages">
		<h3>Music Programming Languages</h3>
		<div style="text-align: left;">
		<ul>
			<li> There are over 100 music-related programming “languages”
			<ul>
				<li> Most are transcription-oriented.  Think HTML, but for music.
				<li> Soundscape DSLs came first ...
				<li> ... but now most center around melodic music.
			</ul>
			<li> Some Music Programming Languages:
			<ul>
				<li> ChucK        — RT synthesis, live coding, pedagogy, acoustic research, algo composition
				<li> Csound        — RTperformance, sound synth, algorithmic composition, acoustic research
				<li> MUSIC-N        — A very early music DSL
				<li> Pure Data (Pd)    — RT audio+video synthesis, like Max/MSP in the “Patcher” family
				<li> Strasheela (→‘12) — Constraint-based composition, based on the Oz language
				<li> SuperCollider (SC) — RT synthesis, live coding, algorithmic composition, acoustic research
				<ul>
					<li> Overtone    — A toolkit w/ a Closure API to SC and the compositional library “Leipzig”
					<li> Skoarcy    — A toolset in Skoar, a high-level music composition DSL that runs on SC
				</ul>
			</ul>
		<ul>
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_transcription">
	<section id="transcription">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_introduction">&#x25c1;</a>
			Song Transcription Languages
			<a href="#/section_euterpea">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_euterpea">
	<section id="euterpea">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_transcription">&#x25c1;</a>
			Euterpea
			<a href="#/section_csound">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>

	<section id="euterpea_geting_started">
		<h2>Euterpea &mdash; Getting Started</h2>
		<div style="text-align: left;">
		<h4>Haskell School of Music</h4>
		<ul>
			<li> Download the PDF "Haskell School of Music" (HSoM.pdf).  (Could also serve as intro to Haskell.)
			<li> Can be thought of as a follow-on to Paul Hudak's "The Haskell School of Expression" (2000).
		</ul>
		<br><br>
		<h4>Installation</h4>
		<ul>
			<li>Read installation instructions at  <a href="http://www.euterpea.com/download-and-installation/">http://www.euterpea.com/download-and-installation/</a>
			<li>Install the 32-bit version of Haskell Platform.  (Sound doesn't work w/ 64-bit version.)
			<li>Install Euterpea2 and the Haskell School of Music (HSoM) from github.
			<li>Test installation ("MUI" = "Musical User Interface)
				<pre style="font-size: 32px; white-space: pre-line;">
					% ghci
					ghci> import Euterpea
					ghci> play $ c 4 qn  -- Play a quarter note, with sensible defaults
					ghci> import HSoM
					ghci> :load  HSoM.Examples.MUIExamples2
					ghci> import HSoM.Examples.MUIExamples2
					ghci> bifurcate     -- GUI app/test that lives in MUIExamples2
				</pre>
		</ul>
		</div>
		<aside class="notes">
			Euterpea is currently maintained by Donya Quick and Dan Winograd-Cort.
		</aside>
	</section>

	<section id="euterpea_representingmusic">
		<h3>Euterpea &mdash; Modeling (Tonal) Music</h3>
		<div style="text-align: left;">
		At the heart of Euterpea's representation of music is the following Primitive:
		<pre style="font-size: 32px; white-space: pre-line;">
		data Primitive = Note Dur Pitch
				| Rest Dur
		</pre>
		<p>
		Type "Music" consists of Primitive events glued together
			sequentially (w/ operator :+:)
			or in parallel (with operator :=:),
			or tagged with some contextual control information.
		<pre style="font-size: 32px; white-space: pre-line;">
		data Music a = Prim (Primitive a)         -- primitive value
				| Music a :+: Music a      -- sequential composition
				| Music a :=: Music a      -- parallel composition
				| Modify Control (Music a) -- modifier
		</pre>
		So the different constructors of Music are Prim, (:+:), (:=:), and Modify. 

		A function "play" converts Music to a list of MEvents,
		and sends them to MIDI output one-by-one, as time advances.
		</div>
		<aside class="notes"/>
	</section>

	<section id="euterpea_frerejacques">
	<h3>Euterpea &mdash; Fr&#x00c8;re Jacques</h3>
		<div style="text-align: left;">
			To play a few simple notes:
			<pre style="font-size: 32px;">
	import Euterpea
	c :: Octave -> Dur -> Music Pitch
	play $ c 4 qn
	mapM (\octave -> play $ c octave qn) [0 .. 8]  -- Play C notes.
			</pre>
			Here’s something slightly more complex: a basic version of Frère Jacques.

			<pre style="font-size: 32px; white-space: pre-line;" font-family="family-name:cursive;">
			twice m = m :+: m
			fj1, fj2, fj3, fj4, fjNotes, fj :: Music Pitch
			fj1 = c 4 qn :+: d 4 qn :+: e 4 qn :+: c 4 qn
			fj2 = e 4 qn :+: f 4 qn :+: g 4 hn
			fj3 = g 4 en :+: a 4 en :+: g 4 en :+: f 4 en :+: e 4 qn :+: c 4 qn
			fj4 = c 4 qn :+: g 3 qn :+: c 4 hn
			fjNotes = twice fj1 :+: twice fj2 :+: twice fj3 :+: twice fj4
			fj = Modify (Tempo 4) $ Modify (Instrument AcousticGrandPiano) fjNotes

			play :: Performable a => Music a -> IO ()
			play fj
			</pre>
		</div>
		<aside class="notes">
			Converting Frère Jacques to a round is left as an exercise.
		</aside>
	</section>

	<section id="euterpea_creatingPerformance">
		<h3>Euterpea &mdash; Creating a Performance</h3>
		<div style="text-align: left;">
		If we replace play with a more explicit version
		<pre style="font-size: 32px; " font-family="family-name:cursive;">
playA :: (ToMusic1 a, Control.DeepSeq.NFData a)
		=> PMap Note1 -> Context Note1 -> Music a -> IO()
		</pre>
		then we need to supply some more information,
		such as how to interpret note attributes (e.g., Pizzicato)
		and phrase attributes (e.g., Crescendo).
		<pre style="font-size: 32px;">
data Context a = Context { cTime :: PTime,          cPlayer :: Player a
			 , cInst :: InstrumentName, cDur    :: DurT
			 , cPch  :: AbsPitch,       cVol    :: Volume
			 , cKey  :: (PitchClass, Mode)
			 }
data Player a = MkPlayer { pName        :: PlayerName   -- ID for selection
			 , playNote     :: NoteFun a    -- Interp. notes
			 , interpPhrase :: PhraseFun a  -- Interp. phrases
			 -- , notatePlayer :: NotateFun -- Removed.
			 }
		</pre>
		</div>
		<aside class="notes">
			<pre style="font-size: 32px; white-space: pre-line;"
			type Performance = [ Event ]
			data MEvent = MEvent { eTime, eInstr, ePitch, eDur, eVol, eParams :: [ Double ] }
							deriving (Show, Eq, Ord)
			perform :: PMap a -> Context a -> Music a -> Performance  -- See p. 138 of HSoM
			type NoteFun a = Context a -> Dur -> a -> Performance
			type PhraseFun a = PMap a -> Context a -> [PhraseAttribute] -> Music a -> (Performance, DurT)
			type NotateFun a = ()
			The PMap is a map from PlayerName (String) to Player (a means of rendering sound & score).
			type PMap a = PlayerName -> Player a
			There is a similar map for channels:
			type ChannelMap = [ (InstrumentName, Channel) ]
			type ChannelMapFun = InstrumentName -> ChannelMap -> (Channel, ChannelMap)
		</aside>
	</section>

	<section id="euterpea_simplePhraseAttribute">
		<h3>Euterpea &mdash; A Simple Phrase Attribute</h3>
		<div style="text-align: left;">
		Let's look at a function to implement the core part
			of one of the simplest phrase attributes, Crescendo,
		which causes the volume of notes to grow over the lifetime of a phrase.
		<pre style="font-size: 32px; " font-family="family-name:cursive;">
myPasHandler :: PhraseAttribute -> Performance -> Performance
myPasHandler (Dyn (Crescendo x)) pf = boostVolsBy x pf
    where t0 = eTime (head performance)
	perfDur :: Dur
	perfDur =  sum $ map eDur performance
	propTime :: PTime -> Rational
	propTime t = (t - t0) / perfDur
	propVolDelta :: PTime -> Rational
	propVolDelta t = x * (propTime t)
	-- inRange mn mx x = min mx $ max mn x
	newVol t v = round((1 + (propVolDelta t)) * (fromIntegral v))
	boostMEventVol (e@MEvent {eTime = t, eVol = v})
		= e { eVol = trace ("Vol=" ++ show (newVol t v))
				   (newVol t v)
		}
	boostVolsBy :: Rational -> [MEvent] -> [MEvent]
	boostVolsBy x pf = map boostMEventVol pf
myPasHandler pa                    pf = defPasHandler pa pf
		</pre>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_soundscape1">
		<h3>Euterpea &mdash; Creating Other Sounds (1/2)</h3>
		<div style="text-align: left;">
		Euterpea also supports more general sound creation using Arrows (see Control.Arrow).
		<pre style="font-size: 32px; " font-family="family-name:cursive;">
(>>>) :: SF a b -> SF b c -> SF a c -- Left-to-right composition
(<<<) :: SF b c -> SF a b -> SF a c -- Right-to-left composition
z <- sigFunc -< (x, y)		    -- Signal function
		</pre>
		<pre style="font-size: 32px; " font-family="family-name:cursive;">
{-# LANGUAGE Arrows +-}
module Euterpea.Examples.SigFuns where
import Euterpea
import Control.Arrow ((>>>),(<<<),arr)

s1 :: Clock c => SigFun c () Double
s1 = proc () -> do
       s <- oscFixed 440 -< ()
       outA -< s

tab1 :: Table
tab1 = tableSinesN 4096 [1]
s2 :: Clock c => SigFun c () Double
s2 = proc () -> do
       osc tab1 0 -< 440
		</pre>
		<aside class="notes">
		</aside>
	</section>

	<section id="euterpea_soundscape1">
		<h3>Euterpea &mdash; Creating Other Sounds (2/2)</h3>
		<div style="text-align: left;">
		<pre style="font-size: 32px; " font-family="family-name:cursive;">
tab2 = tableSinesN 4096 [1.0, 0.5, 0.33]
s3 :: Clock c => SigFun c () Double
s3 = proc () -> do
       osc tab2 0 -< 440


s4 :: Clock c => SigFun c () Double
s4 = proc () -> do
       f0  <- oscFixed 440   -< ()
       f1  <- oscFixed 880   -< ()
       f2  <- oscFixed 1320  -< ()
       outA -< (f0 + 0.5*f1 + 0.33*f2) / 1.83

vibrato ::   Clock c =>
             Double -> Double -> SigFun c Double Double
vibrato vfrq dep = proc afrq -> do
  vib  <- osc tab1  0 -< vfrq
  aud  <- osc tab2  0 -< afrq + vib * dep
  outA -< aud
s5 :: AudSF () Double
s5 = constA 1000 >>> vibrato 5 20
		</pre>
		<aside class="notes">
		</aside>
	</section>
</section>

<section id="section_csound">
	<section id="csound">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_euterpea">&#x25c1;</a>
			Csound
			<a href="#/section_chuck">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_chuck">
	<section id="chuck">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_csound">&#x25c1;</a>
			ChucK
			<a href="#/section_puredata">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>

	<section id="chuck_hellosinewave">
		<h3>ChucK &mdash; Hello Sine Wave</h3>
		<div style="text-align: left;">
		ChucK sends audio to the speakers using a Digital-to-Audio Converter (DAC) denoted by dac.
			Here is a script that plays a 220 Hz sine wave for 5 seconds.
		<pre style="font-size: 32px;">
	<<< "Hello, sine wave" >>>
	SinOsc s => dac;
	0.6 => s.gain;
	220 => s.freq;
	5::second => now;
		</pre>
		In this script:
		<ul>
			<li> Stuff inside the guillemet-like quotes are evaluated and printed to the standard output.
			<li> SinOsc is a Sinusoidal Oscillator type, which has "gain" (i.e., volume) and "freq" (i.e., pitch) properties.
			<li> The '=>' symbol is called the "chuck" operator, since it "throws" or "chucks" a value or stream to its destination.
			<li> Sending a duration to "now" causes time to advance, which streams output to the dac, which creates sound.
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="chuck_moreinfo">
		<h3>ChucK &mdash; More Info</h3>
		</h2>
		<div style="text-align: left;">
		<ul>
			<li> Musical notes can be referenced by their MIDI Note Numbers, and converted to actual frequencies by Std.mtof().
			<li> A 3-note chord can be represented by an array of SinOsc objects: SinOsc chord[3];
			<li> ChucK uses the whimsical terms "shreds" and "spork" for processes and forks.
				<ul>
				<li> Scripted and compiled plug-ins are called Chugens and ChuGins.
				</ul>
			<li> To emulate rests, have time advance in a scope without audio streams.  Add notes in function calls.
			<li> Different instruments can be represented via different "shreds".  Events are used to communicate between shreds.
			<li> For stereo, dac has fields called .left and .right.  For quadraphonic sound, use the .chan field.
			<li> ChucK can be run in what I'll call "performance mode", where a script can be updated as it's running.
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="chuck_echo">
		<h3>ChucK &mdash; Echo Script</h3>
		<div style="text-align: left;">
		Here is a simple "echo" script that reads from a microphone,
			then echoes a slightly delayed and muted version to the speakers.  It uses a built-in Audio-to-Digital Converter (ADC) called adc. 
		<pre style="font-size: 32px;">
	// Feedback setup
	adc => Gain g => dac;
	g => Gain feedback => DelayL delay => g;

	0.75::second => delay.max => delay.delay;
	0.5 => feedback.gain;  // Note: gain < 1.
	0.75 => delay.gain;
	while (true) 1::second => now;
		</pre>
		</div>
		<aside class="notes"/>
	</section>

	<section id="chuck_instrumentModeling">
		<h3>ChucK &mdash; Instrument Modeling</h3>
		<div style="text-align: left;">
		But wait, there's more!  ChucK doesn't just dutifully chuck data around.
		It also allows you to create physical models of the acoustics of instruments,
			such as a ceramic flute, an 18th century violin, or the human voice.
		(This functionality was copied from the earlier Synthesis ToolKit in C++.
		For more details on the modeling, see https://ccrma.stanford.edu/~jos/pas...)
		Here's a simplified version of a plucked string, modified from the book
			<a href="http://www.amazon.com/Programming-Musicians-Digital-Artists-Creating/dp/1617291706/">
				Programming for Musicians and Digital Arists: Creating music with ChucK
			</a>.
		<pre style="font-size: 32px;">
	// Karplus-Strong model of a plucked string
	Impulse imp => Delay plucked => dac;
	plucked => plucked;   // Feedback 
	441.0::samp => plucked.delay; // Sample rate
	0.98 => plucked.gain; // Round-trip gain < 1
	1.0 => imp.next;      // "Pluck" impulse
	5.0::second => now;   // The string resonates
		</pre>
		<ul>
			<li> Note the feedback line that connects plucked to itself.
					This reflects how the action of a plucked string is dependent
					on its action at previous moments in time.
		</div>
		<aside class="notes"/>
	</section>

	<section id="chuck_TheGoodAndTheBad">
		<h3>ChucK &mdash; The Good &amp; The Bad</h3>
		<div style="text-align: left;">
			<ul>
			<li> What ChucK does well: Signal processing and musical instrument acoustic modeling.
			<li> What ChucK doesn’t do as well: Programmatic expressiveness and musical expressiveness.
			<ul>
				<li> Programmatic exp.:
						There's no support for interfaces or higher-order functions, and it’s 2016!
				<li> Musical exp.:
						The language supports abstractions for audio streams,
						but not so much for melodic composition or analysis,
						which are critical for the capturing of many musical idioms.
						(Think of two jazz musicians speaking with each other in shorthand.
						Then again, what programming environment captures this well?)
						This shortcoming is partially addressed by some open source libraries on github
							(e.g., LiCK and Chuckery), but these can only go so far in addressing
							fundamental language limitations.
				</ul>
			</ul>
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_puredata">
	<section id="puredata">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_chuck">&#x25c1;</a>
			Pure Data (Pd)
			<a href="#/section_supercollider">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_supercollider">
	<section id="supercollider">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_puredata">&#x25c1;</a>
			SuperCollider 3 (SC)
			<a href="#/section_strasheela">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>

	<section id="supercollider_language">
		<h3>SuperCollider &mdash; The Language</h3>
		<div style="text-align: left;">
		SuperCollider (named in 1993 after the cancelled Superconducting Super Collider project)
			is an OO language that supports GUI programming,
			with slightly differences between Windows, Mac, and Linux.
		It also supports plug-ins, a means of interactive programming, MIDI data,
			and communication with external devices.
		Functions are invoked via messages, as in Smalltalk.
		<pre style="font-size: 32px;">
	15.squared           // Evaluates to 225.
	[45, 13, 10].sort    // Evaluates to [10, 13, 45]
	5 pow: 8             // Same as 5.pow(8) 
	10.do({ "Hello world".postln })    // Writes to the "Post" pane.
		</pre>
		Caution: Binary operators are evaluated in strict left-to-right order,
			so 1 + 3 * 5 evaluates to 20, rather than 16.
		<br/><br/>
		Here is a brief code snippet that prints out the value of 5! ("five factorial"):
		<pre style="font-size: 32px;">
	var factorial = { | n |
		var result = 1;
		n do: { | i | result = result * (i + 1) };
		result;
	};
	factorial.(5).postln;
		</pre>
		<aside class="notes"/>
	</section>

	<section id="supercollider_basics">
		<h3>SuperCollider &mdash; The Basics</h3>
		<div style="text-align: left;">
		SuperCollider has a client-server design, like IPython/Jupyter.
		The client's interpreter starts automatically.  A local audio server can be started with the command
		<pre style="font-size: 32px;">
		s.boot
		</pre>
		where the variable "s" is reserved to represent the server.
		Client-server synchronization is achieved via communication message tags
			with the intended time of execution in NTP (Network Time Protocol) format.
		<br/><br/>
		To execute a command in the IDE that comes with SC,
			highlight a section of code and type Ctrl-Enter.
		<br/><br/>
		The IDE's Help Browser is easy to use, though some entries have minimal information.
		<br/><br/>
		SuperCollider focus is on creating envelopes of sound with signal processing,
			and combining them with a family of "pattern" classes (e.g., Pbind, Pchain, Prand, etc.).
			While it's theoretically possible to emulate specific musical instruments (e.g., piano, guitar, etc.)
			in SuperCollider, it isn't commonly done.
		</div>
	</section>

	<section id="supercollider_sinewaves">
		<h3>SuperCollider &mdash; Sine Waves</h3>
		<div style="text-align: left;">
		A (non-terminating) sine wave at 440 Hz can be played at half-volume with
		<pre style="font-size: 32px; white-space: pre-line;">
		{ SinOsc.ar(440, phase: 0, mul: 0.5, add: 0) }.play;  // using keyword args
		or
		{ SinOsc.ar(440, 0, 0.5, 0) }.play;  // using positional args
		or just
		{ SinOsc.ar(440) }.play;  // omitting arguments with default values
		</pre>
		where "ar" is the "audio rate" constructor of the SinOsc class.
		The sine wave can be stopped with Ctrl-<period>.
		All the parameters above can be omitted, which will cause default values to be used.
		An important class to become familiar with is UGen, the abstract superclass of all "unit generators".
		These are classes that represent signals.  Examples include:
		<ul>
			<li> Impulse, a class that represents a simple sound;
			<li> LFSaw, a class that represents a low-frequency sawtooth oscillator (cf. SinOsc);
			<li> PMOsc, a class that represents a phase modulation oscillator (cf. SinOsc);
			<li> EnvGen, which wraps another signal with an "envelope";
			<li> Latch, which wraps another signal with an all-or-nothing filter.
		</ul>
		</div>
		<aside class="notes"/>
	</section>

	<section id="supercollider_complex">
		<h3>SuperCollider &mdash; A More Complex Example</h3>
		<div style="text-align: left;">
		Lastly, here is a short piece that creates a cascade of random pitches
			that varies more quickly when the mouse is moved to the right-hand side of the IDE window.
		<pre style="font-size: 32px; ">
{
	var freq, latchrate, index, ratio, env, speed = 9;
	speed = MouseX.kr(2, 20);
	latchrate = speed * 1.61803399;
	index = Latch.kr(
		LFSaw.kr(latchrate, mul: 4, add: 8),
		Impulse.kr(speed)
	);
	freq = Latch.kr(
		LFSaw.kr(latchrate, mul: 36, add: 60),
		Impulse.kr(speed)
	).round(1).midicps;
	ratio = 2.01;
	env = EnvGen.kr(Env.perc(0, 2/speed), gate: Impulse.kr(speed));
	Out.ar(0, PMOsc.ar([freq, freq * 1.5],
		[freq * ratio, freq * 1.5 * ratio],
		index,
		mul: env * 0.5)
)}.play
		</pre>
		</div>
		<aside class="notes">
		When SC was named, the SSC had recently been cancelled by a budget cut.
		The musical language SuperCollider (SC) had a similarly grand vision
			(real-time music synthesis within a garbage-collected language),
			and its creater was skeptical of its long-term success.
		Luckily, SuperCollider has enjoyed greater success than its physics namesake.
		SuperCollider has a bunch of basic types (Integer, Float, Char, String, Symbol,
			Point, Array, Event, Function)
		</aside>
	</section>
</section>

<section id="section_strasheela">
	<section id="strasheela">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_supercollider">&#x25c1;</a>
			Strasheela (Honorable Mention)
			<a href="#/section_resources">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		</div>
		<aside class="notes"/>
	</section>
</section>

<section id="section_resources">
	<section id="resources">
		<h2 style="background-color: #d0d0ff;">
			<a href="#/section_strasheela">&#x25c1;</a>
			Resources
			<a href="#/title">&#x25b7;</a>
		</h2>
		<div style="text-align: left;">
		<p> Music:
		</p>
		<p> Music Programming Languages:
		</p>
		<p> Colophon:
			<br>- <a href="https://github.com/hakimel/reveal.js">reveal.js source code &amp; documentation</a>
		</p>
		</div>
		<aside class="notes"/>
	</section>
</section>

</div> <!-- slides -->
</div> <!-- reveal -->

<script>
	// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
		controls: true,
		progress: true,
		history: true,
		center: false,
		transition: 'slide', // none/fade/slide/convex/concave/zoom

		// Optional reveal.js plugins
		dependencies: [
			{ src: 'js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/notes/notes.js', async: true }
		]
	});
</script>
</body>
</html>

<!-- reveal.js notes:
	Setting up reveal.js:
		http://htmlcheats.com/reveal-js/reveal-js-tutorial-reveal-js-for-beginners/
	Code formatting:
		<pre><code class="hljs" data-trim contenteditable>
		</code></pre>
	Fragments:
		<p class="fragment">one fragment</p>
		<span class="fragment">another</span>
	JavaScript API:
		https://github.com/hakimel/reveal.js#api
	Links to other slides:
		<section id="languages">
		<a href="#/languages">like this</a>
	Markdown:
		Guidelines for reveal.js at https://github.com/hakimel/reveal.js#markdown
		<section data-markdown>
			<script type="text/template">
	Quote templates
		Inline: <q cite="http://foo/bar/baz.html">&ldquo; Lorem ipsum &rdquo;</q>
		Blockquote:
			<blockquote cite="http://foo/bar/baz.html">
				&ldquo; Lorem ipsum .&rdquo;
			</blockquote>
	State:
		Global state:
			Setting data-state="foo" on a slide => "foo" is added as a class to the doc element on open.
		Events:
			See documentation.
	Style changes
		style="font-size: 72px;"
-->